% Ghostscript debug helpers for PostScript debugger
% Purpose:
% - Provide helper procedures that emit clearly delimited output for the
%   debugger adapter to consume. Each helper prints a START and END marker
%   and emits one semantic item per line so the adapter can reliably parse
%   and populate the Variables / Stacks views.
%
% Helpers included:
%  - ps_traverse_route
%
% See per-helper comments below for input, output examples, and parsing regex.
% Note: keep human-readable comments in this file, but avoid printing
% any non-structured lines during helper execution (they would confuse
% parsing in the adapter).

% Usage: [<string>...]
/ps_str_cat {
  <<>> begin
    /str_arr exch def
    0 str_arr {
      length add
    } forall
    /curPos 0 def
    string str_arr {
      1 index exch
      curPos exch
      dup length curPos
      add /curPos exch def
      putinterval
    } forall
  end
} def

% Usage: <executable> <string>
/ps_label_wrapper {
  <<>> begin
  [ exch (PS_) exch ] ps_str_cat
  /marker exch def
  [marker (_START)] ps_str_cat =
  exec
  [marker (_END)] ps_str_cat =
  end
} def

% Usage: <executable>
/ps_print_if_error {
  stopped {
    {
      $error /newerror false put
      $error /errorname get ==
      (in) =
      $error /command get ==
    } (ERROR) ps_label_wrapper
  } if
} def

% Structurally output information of the specified object
% Usage: (<array>|<packedarray>|<dict>)
% Pushed:
%
% Standard Output Format:
% PS_ENTRIES_START
%   PS_ENTRY_START
%     PS_PROP_START
%       PS_NAME_START
%       PS_NAME_END
%       PS_VALUE_START
%       PS_VALUE_END
%     PS_PROP_END
%     ...
%   PS_ENTRY_END
%   ...
% PS_ENTRIES_END
%
% Note: Required attributes are name,type,value
% For other recommended attributes, please refer to (DebugProtocol.Variable)
/ps_struct_print {
<<
  /ps_types <<
    /arraytype 1
    /packedarraytype 1
    /dicttype 1
  >>
>>  begin
  % Usage: any
  /ps_print {
    <<
      /filter_with_type <<
        /packedarraytype {(-packedarray-) =}
        /arraytype {(-array-) =}
      >>
    >> begin
      dup type filter_with_type exch known {
        type filter_with_type exch get exec
      } {
        ==
      } ifelse
    end
  } def

  % Usage: (<array>|<dict>|<packedarray>)
  % If the `length` operation works, then output this property
  /ps_length_prop {
    dup type ps_types exch known {
      {length} stopped {
        pop $error /newerror false put
      } {
        {
          {
            (length) =
          } (NAME) ps_label_wrapper
          {
            =
          } (VALUE) ps_label_wrapper
        } (PROP) ps_label_wrapper
      } ifelse
    } {pop} ifelse
  } def

  % Usage: <array>
  /for_array {
    <<>>begin
    /the_array exch def
      0 1 /the_array load length 1 sub {
        /i exch def
        {
          {
            {
              (name) =
            } (NAME) ps_label_wrapper
            {
              i =
            } (VALUE) ps_label_wrapper
          } (PROP) ps_label_wrapper
          {
            {
              (type) =
            } (NAME) ps_label_wrapper
            {
              /the_array load i get dup type =
            } (VALUE) ps_label_wrapper
          } (PROP) ps_label_wrapper
          {
            {
              (value) =
            } (NAME) ps_label_wrapper
            {
              dup ps_print
            } (VALUE) ps_label_wrapper
          } (PROP) ps_label_wrapper
          ps_length_prop
        } (ENTRY) ps_label_wrapper
      } for
    end
  } def

  % Usage: <dict>
  /for_dict {
    {
      {
        {
          {
            (name) =
          } (NAME) ps_label_wrapper
          {
            exch ==
          } (VALUE) ps_label_wrapper
        } (PROP) ps_label_wrapper
        {
          {
            (type) =
          } (NAME) ps_label_wrapper
          {
            dup type =
          } (VALUE) ps_label_wrapper
        } (PROP) ps_label_wrapper
        {
          {
            (value) =
          } (NAME) ps_label_wrapper
          {
            dup ps_print
          } (VALUE) ps_label_wrapper
        } (PROP) ps_label_wrapper
        ps_length_prop
      } (ENTRY) ps_label_wrapper
    } forall
  } def

  {
    dup type /dicttype eq {
      for_dict
    } {
      for_array
    } ifelse
  } (ENTRIES) ps_label_wrapper
end
} def

% Route-based traversal helper
% Usage: [ (/ostack | /dstack | /estack) (<array_index>|<dict_key>)*]
/ps_traverse_route {
<<
/select <<
  /dstack countdictstack array dictstack
>>
>>begin
  /route exch def
  count array astore select exch /ostack exch put
  select /ostack get aload pop
  countexecstack array execstack select exch /estack exch put
  select route {get} forall ps_struct_print
end
} bind def